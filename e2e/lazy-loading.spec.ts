/**
 * Lazy Loading Performance Tests
 *
 * Story 2.16: Implement Lazy Loading for Email Threads and Large Lists
 * Task 6: Performance Testing and Benchmarking
 *
 * These tests verify:
 * - Lazy-loaded components render correctly (AC 19)
 * - Initial load performance with large email counts (AC 16)
 * - Bundle size enforcement (AC 18)
 */

import { test, expect } from '@playwright/test'
import * as fs from 'fs'
import * as path from 'path'

/**
 * Helper to check if the app is on the welcome/login screen
 * Returns true if authentication is required
 */
async function isOnWelcomeScreen(page: import('@playwright/test').Page): Promise<boolean> {
  // Wait a moment for the app to render
  await page.waitForLoadState('domcontentloaded')
  await page.waitForTimeout(500)

  // Check for welcome screen indicators
  const welcomeIndicators = [
    page.getByText('Welcome to Claine'),
    page.getByRole('button', { name: /connect.*email/i }),
    page.getByText(/your intelligent.*email client/i),
  ]

  for (const indicator of welcomeIndicators) {
    if (await indicator.isVisible({ timeout: 500 }).catch(() => false)) {
      return true
    }
  }

  return false
}

/**
 * AC 19: Test that lazy-loaded components load correctly
 * Note: These tests require authentication - skip if welcome screen is shown
 */
test.describe('Lazy-loaded components', () => {
  test('compose dialog loads on demand', async ({ page }) => {
    // Navigate to the app
    await page.goto('/')
    await page.waitForLoadState('networkidle')

    // Check if we're on the welcome/login screen - skip if so
    if (await isOnWelcomeScreen(page)) {
      test.skip(true, 'App requires authentication - skipping lazy-load UI test')
      return
    }

    // Verify compose button is available
    const composeButton = page.getByRole('button', { name: /compose/i })
    await expect(composeButton).toBeVisible()

    // Click compose to trigger lazy load
    await composeButton.click()

    // Verify compose dialog appears (may show loading skeleton first)
    const composeDialog = page.getByRole('dialog')
    await expect(composeDialog).toBeVisible({ timeout: 5000 })

    // Verify compose dialog has loaded its content
    const toField = page
      .locator('input[placeholder*="To"]')
      .or(page.locator('[data-testid="compose-to"]'))
    await expect(toField).toBeVisible({ timeout: 5000 })
  })

  test('search/command palette loads on demand', async ({ page }) => {
    await page.goto('/')
    await page.waitForLoadState('networkidle')

    // Check if we're on the welcome/login screen - skip if so
    if (await isOnWelcomeScreen(page)) {
      test.skip(true, 'App requires authentication - skipping lazy-load UI test')
      return
    }

    // Open command palette with keyboard shortcut
    await page.keyboard.press('Meta+k')

    // Or try clicking search if shortcut doesn't work
    const searchInput = page.getByRole('combobox').or(page.locator('[data-testid="search-input"]'))
    await expect(searchInput).toBeVisible({ timeout: 5000 })
  })

  test('shortcut overlay loads on demand', async ({ page }) => {
    await page.goto('/')
    await page.waitForLoadState('networkidle')

    // Check if we're on the welcome/login screen - skip if so
    if (await isOnWelcomeScreen(page)) {
      test.skip(true, 'App requires authentication - skipping lazy-load UI test')
      return
    }

    // Open shortcut overlay with ? key
    await page.keyboard.press('Shift+?')

    // Verify overlay appears
    const overlay = page
      .locator('[data-testid="shortcut-overlay"]')
      .or(page.getByRole('dialog', { name: /keyboard shortcuts/i }))
    await expect(overlay).toBeVisible({ timeout: 5000 })
  })
})

/**
 * AC 18: Test that bundle sizes meet budgets
 * This reads the bundle-sizes.json report generated by npm run bundle:check
 */
test.describe('Bundle size enforcement', () => {
  test('bundle sizes are within budget', async () => {
    const reportPath = path.join(process.cwd(), 'reports', 'bundle-sizes.json')

    // Check if report exists (generated by npm run bundle:check)
    const reportExists = fs.existsSync(reportPath)
    if (!reportExists) {
      test.skip()
      return
    }

    const report = JSON.parse(fs.readFileSync(reportPath, 'utf-8'))

    // AC 8: Total bundle <500 KB
    expect(report.total.gzipSize).toBeLessThan(512000) // 500 KB in bytes

    // Check each module is within its budget
    for (const [name, module] of Object.entries(report.modules) as [
      string,
      { budget: number; gzipSize: number },
    ][]) {
      if (module.budget > 0) {
        expect(
          module.gzipSize,
          `Module ${name} exceeds budget (${module.gzipSize} > ${module.budget})`
        ).toBeLessThan(module.budget)
      }
    }
  })

  test('initial app chunk is under 200KB gzip', async () => {
    const reportPath = path.join(process.cwd(), 'reports', 'bundle-sizes.json')

    if (!fs.existsSync(reportPath)) {
      test.skip()
      return
    }

    const report = JSON.parse(fs.readFileSync(reportPath, 'utf-8'))

    // Find the main index chunk (app code)
    const appModule = report.modules.app
    if (appModule && appModule.gzipSize) {
      // AC 9: Email list chunk <200 KB (main app bundle)
      expect(
        appModule.gzipSize,
        `Main app chunk (${appModule.gzipSize} bytes) exceeds 200KB budget`
      ).toBeLessThan(204800) // 200 KB
    }
  })

  test('lazy chunks are under 150KB each', async () => {
    const reportPath = path.join(process.cwd(), 'reports', 'bundle-sizes.json')

    if (!fs.existsSync(reportPath)) {
      test.skip()
      return
    }

    const report = JSON.parse(fs.readFileSync(reportPath, 'utf-8'))
    const maxChunkSize = 153600 // 150 KB in bytes

    // Check feature chunks (these are the lazy-loaded ones)
    for (const chunk of report.chunks) {
      if (chunk.name.startsWith('feature-')) {
        expect(
          chunk.gzipSize,
          `Feature chunk ${chunk.name} (${chunk.gzipSize} bytes) exceeds 150KB budget`
        ).toBeLessThan(maxChunkSize)
      }
    }
  })
})

/**
 * AC 16: Test initial load with large email count
 * Note: This test requires a populated database which may not be available in CI
 */
test.describe('Performance with large datasets', () => {
  test('initial page load completes within 3 seconds', async ({ page }) => {
    // Start timing
    const startTime = Date.now()

    // Navigate and wait for the app to be interactive
    await page.goto('/')

    // Wait for either the main app content or welcome screen to be visible
    // Both indicate the app has loaded and is interactive
    await Promise.race([
      page.waitForSelector('[data-testid="app-main"]', { timeout: 10000 }),
      page.waitForSelector('[data-testid="welcome-screen"]', { timeout: 10000 }),
      page.locator('text=/connect your email/i').waitFor({ timeout: 10000 }),
      page.waitForLoadState('domcontentloaded').then(() => page.waitForTimeout(500)),
    ]).catch(() => {
      // Fallback: wait for any visible content
      return page.waitForLoadState('domcontentloaded')
    })

    const loadTime = Date.now() - startTime

    // AC 12: TTI < 3 seconds
    expect(loadTime, `Initial load took ${loadTime}ms, exceeds 3s budget`).toBeLessThan(3000)
  })

  test('email list renders efficiently with virtualization', async ({ page }) => {
    await page.goto('/')
    await page.waitForLoadState('networkidle')

    // Check that only a limited number of email rows are in the DOM
    // (virtualization should only render visible + buffer rows)
    const emailRows = await page.locator('[data-testid="email-row"]').all()

    // With virtualization, we expect max ~50-60 rows rendered at a time
    // (visible + 25 overscan buffer * 2)
    // If there are emails, expect this to be less than 100
    if (emailRows.length > 0) {
      expect(
        emailRows.length,
        `Too many email rows rendered (${emailRows.length}), virtualization may not be working`
      ).toBeLessThan(100)
    }
  })

  test('infinite scroll loads more emails', async ({ page }) => {
    await page.goto('/')
    await page.waitForLoadState('networkidle')

    // Find the email list container
    const emailList = page
      .locator('[data-testid="email-list"]')
      .or(page.locator('.overflow-auto').first())

    // Get initial count of rendered emails
    const initialRows = await page.locator('[data-testid="email-row"]').count()

    if (initialRows === 0) {
      // No emails to test infinite scroll
      test.skip()
      return
    }

    // Scroll to bottom to trigger infinite scroll
    await emailList.evaluate((el) => {
      el.scrollTop = el.scrollHeight
    })

    // Wait a moment for new emails to load
    await page.waitForTimeout(1000)

    // Check if "loading more" indicator appears or more emails loaded
    const loadingIndicator = page.getByText(/loading more/i)
    const newRows = await page.locator('[data-testid="email-row"]').count()

    // Either loading indicator should have appeared, or more rows should be rendered
    const loadingOrMoreRows = (await loadingIndicator.isVisible()) || newRows >= initialRows

    expect(loadingOrMoreRows).toBe(true)
  })
})
